# *i-bem.js*: User Guide #

# Overview #

## *i-bem.js*: Javascript framework for BEM ##

*i-bem.js* is a JavaScript framework for web-development within [BEM-methodology](http://en.bem.info/method/). Using
*i-bem.js* one can:

 * develop web interface in terms of blocks, elements, modifiers;
 * describe a block's behaviour in a declarative style as a set of states;
 * integrate easily JavaScript code with CSS in BEM style and with BEMHTML-templates;
 * flexibly override behaviour of library blocks.

*i-bem.js* is not suitable for:

 * replacing the general purpose framework, such as jQuery.


**Краткий обзор содержания документа**:

* [Общие сведения](#intro) о фреймворке: связь с понятиями БЭМ
  предметной области, краткое описание модульной структуры фреймворка,
  шаблонного проекта, инструментов для сборки кода, написанного с
  использованием *i-bem.js*.

* [Привязка JS-блоков к HTML](#html) — синтаксис указания JS-блоков на
  HTML-странице, типы соотношения HTML-элементов и JS-блоков.

* [Декларация блока](#decl) — синтаксис описания JS-блоков.

* [Работа с DOM-деревом](#dom) — API для работы с DOM-узлами блоков:
  элементы, динамическое изменение DOM-дерева (AJAX).

* [События](#events) — событийная модель *i-bem.js*: DOM-события,
  BEM-события, делегирование событий.

* [Состояния блока](#states) — модификаторы, триггеры на смену
  состояний (установку модификаторов), инициализация экземпляров
  блоков.

* [Взаимодействие блоков](#ibc) — API для обращения из блока к другим блокам.

* [Что дальше?](#docs) — ссылки на документацию и дополнительные материалы.
* 
## BEM-methodology and JavaScript ##
As far as BEM-methodology is concerned, web interface is built  of independent **blocks** (in which **elements** are allocated). Both blocks and elements may have states, described by **modifiers**.

Web interface work is provided by multiple  **technologies**
(HTML, CSS, JS...), a description of a block consists of the implementations of these technologies. Usually implementation consists of a few files, for example:

 * `my-block.css` — describes block's appearance;
 * `my-block.bemhtml` — templates for generating block's HTML-view;
 * `my-block.js` — describes block's **dynamic behavior** in browser.

*i-bem.js* framework allows to decompose client JavaScript into components in BEM-terms:

 + **Block** is a JS component that describes the way the same interface elements work.
 For example, all buttons may be implemented as a `button` block. Then, according to the BEM-methodology, `button.css` determines the appearance of the buttons, `button.js` — determines the way they work.
 + Each page can contain more than one **instance** of a block (for example, a button). Each instance of the block corresponds to the JS object that is created dynamically in the browser's memory and stores the state of the instance. JS-object stores a link to the DOM-node that is bound to the instance of the block. 
 + **Elements** are DOM-nodes nested on DOM-node block with `class` attribute, indicating their role in BEM-subject domain (the names of blocks and elements). Elements of a block are available through the [JS-API](#elem-api) of the instance of the block.
 + **Modifiers** store information on a block state and its elements. Modifier state is written in `class` attribute on a block's DOM-nodes and elements. 
   Modifiers are operated via [JS-API](#mods-api) of the instance of the block.



## How to use i-bem.js ##

*i-bem.js* framework is included in [bem-core](http://github.com/bem/bem-core/).

Implementation consists of two modules:

* [`i-bem`][] module.<br/> 
  Basic implementation of i-bem JS-block, which all the blocks in *i-bem.js* inherit from. i-bem block is written to be used in any JS-environment, both on client and server sides (for example, in Node.js).
* [`i-bem__dom`][] module.<br/> Basic implementation of a block linked to DOM-node. Basic implementation of a block linked to DOM-node. Is intended for using on the client side, based on browsers' work with DOM. Depends on jQuery. 

Dependencies:

 * jQuery (only for `i-bem__dom` module). When using bem-core, a separate installation of jQuery is not required.
 * [ymaps/modules][ymaps] modular system. When using [bem-tools][] along with `.browser.js` technology (and derrivatives based on it), this dependancy is resolved automatically.

One can use *i-bem.js* as a part of full stack of BEM-tools. In this case it is convinient to create a project based on [project-stub](http://github.com/bem/project-stub/) template repository, which automatically installs the dependent libraries.

If one doesn't plan on using other technologies of BEM-platform, one can copy the bem-core library code to the current project.


## Build ##

According to BEM methodology web development is modular: each block is programmed separately. The final sourcecode of web pages is formed from the separate blocks code by use of **build** proceedures.


In a file system it is convenient to represent a block as a catalog, and the implementation of a block in each of the technologies as a separate file:
    desktop.blocks/
        my-block/
            my-block.css
            my-block.js
            my-block.bemhtml
            ...

    desktop.blocks/
        other-block/
            other-block.css
            other-block.js
            other-block.bemhtml
            ...

The code of the used blocks on each web page can be built in single files: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

There are two instruments for building code of the resultant pages from separate blocks description: 

* [bem-tools](http://github.com/bem/bem-tools/);
* [enb](https://github.com/enb-make/enb) along with [enb-modules](https://github.com/enb-make/enb-modules).


## Why i-bem.js is called that way ##

According to BEM-methodology, basic JS-library of BEM platform was originally developed as a special helper block. 
This approach allows us to work with base libraries in the same way as with common blocks. Particularly, it allows to structure the code in terms of elements and modifiers, and flexibly set up the library behavior at different levels.

It was common for BEM to give names to helper blocks with `i-` prefixes . So, the name `*i-bem.js*` read as "implementation of the `i-bem` block in `js` technology".


# Binding JS blocks to HTML #

JavaScript components in *i-bem.js*  are used for making HTML-elements of a page dynamic. A typical task for JS block is to bind certain events handling to the specific HTML fragment.

In developing a web interface with *i-bem.js* framework there is a primary structure — the HTML document tree. 
In the HTML tree there are nodes, bound with JS blocks — interactive interface elements . The point of a JS block binding is a HTML element.  The name of the block is indicated in its `class` attribute , [block parameters](#html-syntax) are indicated in `data-bem` attribute.

When loading а page, the browser runs [blocks initialization](#init). During the initialization process blocks instances are generated – JS objects for all the blocks, mentioned in HTML elements on the page. 
JS object, bound to the HTML element handles its [DOM events](#dom-events) and stores the state of the given instance of a block.


* Таким образом, в HTML-дереве каждому экземпляру блока соответствует HTML-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока
   на странице (HTML-элементу) должен быть привязан JS-объект —
   экземпляр блока. Это делается за счет добавления [block parameters](#html-syntax) в
   атрибуты `class` и `data-bem` HTML-элемента.
 * JS-объект, привязанный к HTML-элементу, обрабатывает происходящие на
   нем [DOM-события](#dom-events) и хранит состояние данного экземпляра блока.
 * *i-bem.js* также дает возможность реализовать JS-компонент, не
   привязанный к HTML, — [блок без DOM-представления](#i-blocks),
   имеющий API, аналогичное обычным блокам.

Описанный подход привязки JavaScript-компонент к HTML имеет следующие преимущества:

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов
   интерфейса до окончания загрузки всех данных страницы (например,
   изображений).

<a name="html-syntax"></a>

## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу (например, `<div>...</div>`), необходимо:

 * **Отметить блок в HTML-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).

```HTML
<div class="my-block">...</div>
```

 * **Инициализировать экземпляр блока**.<br/>
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.

```HTML
<div class="my-block i-bem">...</div>
```

 * **Передать параметры экземпляру блока**.<br/> Поместить параметры
 блока в атрибут `data-bem`. Параметры блока записываются в формате
 JSON в виде хэша структуры __имя блока—хэш параметров__. Параметры
 передаются экземпляру блока в момент инициализации
 ([подробнее...](#data-bem)).

```HTML
<div class="my-block i-bem" data-bem='{ "my-block": { "name": "ya" } }'>...</div>
```

Одному HTML-элементу не обязательно должен соответствовать один
экземпляр блока. Возможны следующие типы связи между блоками и
HTML-элементами:

### Один HTML-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `my-block`, параметры блока — пустой список `{}`.

```HTML
<div class="my-block i-bem" data-bem='{ "my-block": {} }'>
    ...
</div>
```


<a name="mixes"></a>

### Один HTML-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном HTML-элементе в БЭМ-методологии называется **микс**.

Пример: HTML-элемент `div`, на котором размещены блок `user` с
параметром `name`: `pushkin` и блок `avatar` с параметром `img`: `http://...`.

```HTML
<div class="user avatar i-bem"
    data-bem='{
        "user": { "name": "pushkin" },
        "avatar": { "img": "http://..." }
     }'>
     ...
</div>
```

<a name="distrib-block"></a>

### Один JS-блок на нескольких HTML-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из
нескольких компонент, сосотяние которых должно быть
согласовано. Например, виджет «вкладки», где клик по заголовку вкладки
(один HTML-элемент), меняет содержимое вкладки (другой
HTML-элемент). Другой пример — маркер, обозначающий точку на карте
(первый элемент) и связанное с ним описание точки в списке рядом с
картой (второй элемент).

Чтобы привязать экземпляр блока к нескольким HTML-элементам, нужно в параметрах
блока на всех связанных с ним HTML-элементах указать одинаковое значение `id`. В
качестве значения `id` может выступать произвольная строка.

Пример: Экземпляр блока `notebook` привязан к HTML-элементам `div` и `span`, в
параметрах блока указан общий `id` — `maintab`.

```HTML
<div class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</div>
...
<span class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</span>
```

В результате при инциализации блоков создается один JS-объект, поле
 [`{jQuery} domElem`](#domElem) которого содержит ссылки на оба DOM-узла.

Идентификатор `id` используется *только в момент инициализации*
экземпляра блока. Значение `id` должно быть уникальным в пределах
экземпляров одного блока в рамках одной
[волны инициализации](#init-wave).


<a name="i-blocks"></a>

### Блоки без DOM-представления ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с
бэкэндом, общие вычисления и т.п. — при работе с *i-bem.js* можно
оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать
такие блоки к HTML-дереву икусственно, *i-bem.js* предоставляет
возможность создавать блоки без DOM-представления.

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * Декларируются как [доопределение модуля `i-bem`](#bem-decl), а не
   `i-bem__dom`, как блоки с DOM-представлением.
 * Должны быть [инициализированы явно](#init-bem).


## Синтаксис передачи параметров ##

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации.
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному HTML-элементу.

<a name="data-bem"></a>

В значении атрибута `data-bem` указываются параметры *всех JS-блоков, размещенных на данном узле*.
Параметры передаются в формате JSON в виде хэша:

 + ключ — `{String}` имя блока;
 + значение — `{Object}` параметры данного блока. Если данному экземпляру блока не требуются
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости
   парсить значение атрибута `class`, что упрощает и ускоряет
   инициализацию блоков.
 * Это же решение позволяет размещать несколько блоков на одном
   HTML-элементе без необходимости множить атрибуты элемента.

Значение атрибута `data-bem` должно содержать валидный JSON.

# Декларация блока #

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования:

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока).
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в *i-bem.js* принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как
утверждения вида _набор условий — реакция блока_.


## Синтаксис декларации ##

Чтобы декларировать новый JS-блок **с DOM-представлением**
(привязанный к HTML-элементу), необходимо доопределить [ymaps][]-модуль `i-bem__dom`.

Блоки декларируются с помощью метода `decl`, принимающим три
параметра:

1. Имя блока `{String}` или [описание блока](#decl-selector) `{Object}`.
2. Методы экземпляра блока — `{Object}`.
3. Статические методы — `{Object}`.

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl(/* имя или описание блока */,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }
);

provide(DOM);

});
```

-------------------------------------------------------------------------------

**NB** С точки зрения модульной системы [ymaps][], декларации разных
  блоков представляеют собой переопределение одного и того же модуля
  `i-bem__dom`. Однако с точки зрения *i-bem.js* таким образом создаются
  *разные объекты* для построения экземпляров блоков.

-------------------------------------------------------------------------------

<a name="bem-decl"></a>

Блоки, не имеющие DOM-представления, декларируются как доопределение [ymaps][]-модуля `i-bem`.
Для декларации используется метод `decl`, принимающий те же параметры,
что и метод `decl` модуля `i-bem__dom`:

```js
modules.define('i-bem', function(provide, BEM) {

BEM.decl(/* имя или описание блока */,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }
);

provide(BEM);

});
```


-------------------------------------------------------------------------------

**NB**: Оформлять инфраструктурный код в виде блока без
  DOM-представления удобно, если в нем планируется использовать API
  БЭМ-блоков (состояния, выражаемые модификаторами, BEM-события и
  т. п.). Если использовать БЭМ-предметную область не планируется,
  инфраструктурный код можно оформлять в виде [ymaps][]-модуля. Например:

```js
modules.define('router', function(provide) {

provide({
    route : function() { /* ... */ }
});

});
```

-------------------------------------------------------------------------------

<a name="decl-selector"></a>


## Описание блока в декларации ##

Первый параметр метода `decl` представляет собой описание блока, в
котором будут применяться объявленные в декларации методы. Описание
обязательно содержит имя блока и может дополнительно содержать:

* ограничение сферы действия декларации определенной модификацией
  блока;
* список родительских блоков, методы которых должен наследовать данный
  блок.

Описание может быть задано в одной из двух форм:

1. Имя блока — строка.<br/>
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

    ```js
DOM.decl('button',
    { /* методы экземпляра */ },
    { /* статические методы */ }
);
    ```

2. Описание блока — хэш.<br/> Например, так может выглядеть декларация
   методов для блока `button` с модификатором `type` в значении
   `link` (описывает поведение псевдокнопок):

    ```js
DOM.decl({ block: 'button', modName: 'type', modVal: 'link' },
    { /* методы экземпляра */ },
    { /* статические методы */ }
);
    ```

-------------------------------------------------------------------------------

**NB** Если в декларации для блока с указанием конкретных
  модификаторов описаны статические методы, они будут применяться ко всем
  экземплярам данного блока *вне зависимости от значений
  модификаторов*. Модификаторы являются свойствами экземпляров блоков,
  а статические методы принадлежат классу блока и поэтому не могут
  учитывать ограничения по модификатору.

-------------------------------------------------------------------------------


## Контекст ##

**Методы экземпляра блока** исполняются в контексте JS-объекта
экземпляра блока. Соответственно, ключевое слово `this` в методах
экземпляра блока ссылается на JS-объект **экземпляра блока**.

**Статические методы** исполняются в контексте JS-объекта,
  соответствующего классу блока. Соответственно, ключевое слово `this`
  в статических методах блока ссылается на **класс блока**, а не на
  экземпляр.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому
   принадлжит экземпляр. Определен в методах экземпляра блока. Для
   статических методов не имеет смысла и не определен.

    Пример: Вызов статического метода `staticMethod` в методе
    `onEvent` экземпляра блока `my-block`.

```js
DOM.decl('my-block', {
    onEvent: function() {
        this.__self.staticMethod(); // вызов статического метода
        this.doMore();
    },
    {
        staticMethod: function() { /* ... */ }; // определение статического метода
    }
});
```

 + `this.__base`: Ссылается на реализацию метода в базовом классе, от которого наследуется данный.
    Позволяет выполнить super call. Определен в методах экземпляра
    блока и в статических методах блока.

    Пример: вызов (и модификация) метода `_onClick` родительского класса (базовой реализации метода в классе `button`).

```js
DOM.decl({ block: 'my-button', baseBlock: 'button' }, {
    _onClick: function() {
        this.__base();
        this.doMore();
    }
);
```

-------------------------------------------------------------------------------

**NB** При разработке блоков с использованием *i-bem.js* внутренним
  методам блока, не предназначенным для использования извне, принято
  давать имена, начинающиеся с символа подчеркивания. Например,
  `_onClick`.

-------------------------------------------------------------------------------


# Работа с DOM-деревом #

<a name="domElem"></a>

## DOM-узел экземпляра блока ##

Все экземпляры блоков, привязанные к DOM-дереву, содержат в поле
`{jQuery} this.domElem` jQuery-объект, ссылающийся на один или
несколько DOM-узлов, с которыми связан данный экземпляр блока.

<a name="elem-api"></a>

## Элементы ##

БЭМ-элементы блоков представлены в *i-bem.js* как DOM-узлы, вложенные
в DOM-узел экземпляра блока. Для обращения к DOM-узлам элементов и
работы с их модификаторами, следует использовать API, предоставляемое
экземпляром блока.

Экземпляр блока предоставляет два метода для обращения к элементам данного
    экземпляра:

* Кеширующий доступ: `elem(elems, [modName], [modVal])`. Элемент,
  полученный таким образом, нет необходимости сохранять в переменную.

```js
DOM.decl('b-link', {
    setInnerText: function() {
        this.elem('inner').text('Текст ссылки');
        /* ... */
        this.elem('inner').text('Другой текст');
    }
);
```

* Некеширующий доступ: `findElem(elems, [modName], [modVal])`.

```js
DOM.decl('b-link', {
    setInnerText: function() {
        var inner = this.findElem('inner');
        inner.text('Текст ссылки');
        /* ... */
        inner.text('Другой текст');
    }
});
```

При [динамическом добавлении и удалении элементов блока](#dynamic) может
возникнуть необходимость сброса кеша элементов. Для этого предназначен
метод `dropElemCache('elements')`. В качестве параметра указывается
разделенный пробелами список имен элементов, кеш для которых нужно
сбросить:

```js
DOM.decl('attach', {
    clear: function() {
        DOM.destruct(this.elem('control'));
        DOM.destruct(this.elem('file'));
        return this.dropElemCache('control file');
    }
});
```


Полное описание API для работы с элементами содержится в
исходном коде модуля [`i-bem__dom`][].

<a name="dynamic"></a>

## Динамическое обновление блоков и элементов в DOM-дереве ##

В современных интерфейсах зачастую необходимо создавать новые
фрагменты DOM-дерева и заменять старые в процессе работы (AJAX). В
*i-bem.js* предусмотрены следующие функции для добавления и замены
фрагментов DOM-дерева:

* `append` — добавить DOM-фрагмент в конец указанного контекста;
* `prepend` — добавить DOM-фрагмент в начало указанного контекста;
* `before` — добавить DOM-фрагмент перед указанным контекстом;
* `after` — добавить DOM-фрагмент после указанного контекста;
* `update` — заместить DOM-фрагмент внутри указанного контекста;
* `replace` — заместить указанный контекст новым DOM-фрагментом.

Все функции автоматически выполняют [инициализацию блоков на
обновленном фрагменте DOM-дерева](#init-ajax).

Чтобы упростить создание БЭМ-сущностей на обновляемых фрагментах
DOM-дерева, можно использовать шаблонизатор
[BEMHTML](http://ru.bem.info/articles/bemhtml-reference/), подключив
его в качестве [ymaps][]-модуля. BEMHTML позволяет по описанию
БЭМ-сущностей в формате
[BEMJSON](http://ru.bem.info/articles/bemhtml-reference#bemjson)
генерировать DOM-узлы в соответствии с правилами именования БЭМ
непосредственно в JS-коде блока.

**Пример**: В методе `_updateFileElem` блока `attach` выполняется
  удаление элемента `file`, если он существовал, и генерация нового
  элемента с помощью функции `BEMHTML.apply`:

```js
modules.define(
    'i-bem__dom',
    ['BEMHTML', 'strings__escape'],
    function(provide, BEMHTML, escape, DOM) {

DOM.decl('attach', {
    _updateFileElem : function() {
        var fileName = extractFileNameFromPath(this.getVal());
        this.elem('file').length && DOM.destruct(this.elem('file'));
        DOM.append(
            this.domElem,
            BEMHTML.apply({
                block : 'attach',
                elem : 'file',
                content : [
                    {
                        elem : 'icon',
                        mods : { file : extractExtensionFromFileName(fileName) }
                    },
                    { elem : 'text', content : escape.html(fileName) },
                    { elem : 'clear' }
                ]
            }));
        return this.dropElemCache('file');
    }
});

provide(DOM);

});
```


# События #

В *i-bem.js* поддерживается два вида событий:

<a name="dom-events"></a>

* **DOM-события** — JavaScript-события, возникающие на DOM-узлах,
  соответствующих блокам. Это события, отражающие взаимодействие
  пользователя с интерфейсом (клик, наведение мыши, ввод текста и
  т.п.). DOM-события обычно обрабатывает тот экземпляр блока, на
  DOM-узле которого они возникли.
* **BEM-события** — собственные события, которые генерируются
  блоками. Позволяют организовать API для
  [взаимодействия с блоком](#ibc). BEM-события обычно обрабатывает
  экземпляр блока, отслеживающий состояние других блоков, на которых
  генерируются события.

Планируя архитектуру интерфейса, нужно учитывать, что DOM-события
следует использовать только во *внутренних* процедурах блока. Для
взаимодействия блока с *внешней* средой (другими блоками),
предназначены BEM-события.


-------------------------------------------------------------------------------

**NB** Работа с DOM-событиями полностью реализована средствами
  фреймворка jQuery.

-------------------------------------------------------------------------------


<a name="delegated-events"></a>

## Делегирование событий ##

Обработка BEM- и DOM-событий может быть **делегирована** контейнеру
(всему документу или конкретному DOM-узлу). В этом случае контейнер
служит точкой обработки событий, возникающих на любом из
дочерних узлов контейнера, даже если в момент подписки на события
некоторые из дочерних узлов еще не существовали.

Например, блок меню может содержать вложенные блоки (или элементы — в
зависимости от конкретной реализации блока) — пункты меню. Обработку
кликов на пунктах меню имеет смысл делегировать самому блоку
меню. Это, во-первых, позволяет сэкономить затраты ресурсов на
подписку на события (дешевле подписаться на одно событие контейнера,
чем на много событий элементов). Во-вторых, это дает возможность более
гибко изменять состав меню: добавлять и удалять пункты, не выполняя
при этом подписку на события добавленных пунктов меню и отмену
подписки на события удаленных.

* [**Делегирование DOM-событий**](#dom-events-delegated) можно
  использовать для обработки DOM-событий, происходящих на DOM-узле
  экземпляра блока или на DOM-узлах его элементов. Делегирование
  DOM-событий может выполняться либо для всех экземпляров блоков
  данного типа в пределах документа, либо только для экземпляров
  блоков внутри указанного контекста (фрагмента HTML-дерева).

    Контейнером, которому делегируется обработка DOM-событий, всегда
    выступает `window.document`.


* [**Делегирование BEM-событий**](#bem-events-delegated) следует
  использовать для обработки событий на *экземплярах блоков*,
  содержащихся внутри указанного DOM-узла.

    Контейнером, которому делегируется обработка BEM-событий, может
    служить **произвольный DOM-узел**. По умолчанию в качестве
    контейнера выступает весь документ (`window.document`). Часто блок
    обрабатывает BEM-события вложенных блоков, тогда в качестве
    контейнера следует указать DOM-узел блока-обработчика
    [`this.domElem`](#domElem).


Полный список хелперов для подписки на делегированные события
можно найти в исходном коде модуля [`i-bem__dom`][].


## DOM-события ##

Для подписки на DOM-события на узлах, связанных с блоком или
элементом, используются метод экземпляра блока `bindTo([elem], event,
handler)`.

**Пример**: В момент [инициализации экземпляра блока](#init)
`my-block` выполняется подписка на событие `click`, при наступлении
которого блок выставляет себе [модификатор](#modifier) `size` в
значение `big`.

```js
DOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.domElem
                    this.setMod('size', 'big');
                });
            }
        }
    }
});
```

**Пример**: При [инициализации экземпляра блока](#init) `my-form` выполняется
  подписка на событие `click` элемента `submit`, при наступлении
  которого будет вызван метод экземпляра блока `_onSubmit`.

```js
DOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('submit', 'click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.elem('submit')
                    this._onSubmit();
                });
            }
        }
    },

    _onSubmit : function() { /* ... */ }
});
```

-------------------------------------------------------------------------------

**NB** Функция-обработчик выполняется в контексте того экземпляра
  блока, в котором возникло событие.

-------------------------------------------------------------------------------

**Удаление подписки** на DOM-события выполняется автоматически при
уничтожении экземпляра блока. Если необходимо удалить подписку вручную
в процессе работы блока, следует использовать метод
`unbindFrom([elem], event, handler)`.

<a name="dom-events-delegated"></a>

### Делегирование DOM-событий ###

Делегирование обработки DOM-событий выполняется с помощью метода
`liveBindTo([elem], event, handler)`. В декларации блока точкой,
зарезервированной для подписки на делегированные DOM-события, служит
свойство `live` в разделе статических методов блока.

**Пример**: Все экземпляры блока `menu` подписываются на
  делегированное DOM-событие `click` своих элементов `item`. Метод
  `_onItemClick` экземпляра блока `menu` будет выполняться при клике
  на любой пункт (элемент `item`) в этом меню, вне зависимости от того,
  существовал ли этот пункт в момент инициализации экземпляра блока.

```js
DOM.decl('menu', {
    _onItemClick : function(e) {
        var clickedItem = $(e.currentTarget); // элемент 'item' блока 'menu', на котором слушается DOM-событие 'click'
    }
}, {
    live : function() {
        this.liveBindTo('item', 'click', function() {
            this._onItemClick();
        });
        return false; // если инициализация блока не может быть отложена
    }
});
```

По умолчанию при наличии в декларации блока свойства `live`
инициализация экземпляров блока будет *отложена* до момента, когда
экземпляр блока потребуется в работе
([ленивая инициализация](#init-live)). Таким моментом может быть
DOM-событие на экземпляре блока, на которое выполнена делегированная
подписка, или обращение к экземпляру блока [из другого блока](#ibc).
Если инициализация блока не может быть отложена (требуется
[автоматическая инициализация](#init-auto)), следует вернуть `false` в
результате выполнения функции в значении свойства `live`.

-------------------------------------------------------------------------------

**NB** Функция-обработчик выполняется в контексте ближайшего блока
  данного типа на пути распространения DOM-события (снизу вверх по
  DOM-дереву).

-------------------------------------------------------------------------------

**Удаление подписки** на делегированные DOM-события никогда не
  выполняется автоматически. Если подписку необходимо удалить, следует
  воспользоваться методом `liveUnbindFrom([elem], event, [handler])`.


### Объект DOM-события ###

В качестве параметра функции-обработчику передается jQuery-объект,
описывающий DOM-событие — [`{jQuery.Event}`](http://api.jquery.com/category/events/event-object/).

Если DOM-событие было сгенерировано вручную, все параметры, переданные
функции `trigger` при создании события, будут переданы
функции-обработчику в том же порядке после объекта события.



<a name="bem-events"></a>

## BEM-события ##

В отличие от DOM-событий, BEM-события генерируются не на
DOM-элементах, а на **экземплярах блоков**. Элементы блоков не могут
генерировать BEM-события.

Чтобы сгенерировать BEM-событие, используется метод экземпляра блока
`emit(event)`.

**Пример**: Когда пользователь кликает по DOM-элементу кнопки `submit`
(происходит DOM-событие `click`), выполняется метод `_onClick()`
экземпляра блока `submit`, в котором генерируется **BEM-событие**
`click` в том случае, если у блока в этот момент не выставлен
модификатор `disabled`:

```js
DOM.decl('submit', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.bindTo('click', this._onClick); // подписка на DOM-событие "click"
            }
        }
    },

    _onClick: function() {
        if(!this.hasMod('disabled')) {
            this.emit('click'); // создание BEM-события "click"
        }
    }
});
```

Для подписки на BEM-события экземпляров блоков используются методы
экземпляра блока `on(event, [data], handler, [handlerCtx])`.

**Пример**: В момент инициализации HTML-формы (экземпляра блока `my-form`)
выполняется поиск вложенной в форму кнопки `submit` и подписка на
BEM-событие `click` этой кнопки. В результате при нажатии на кнопку
(экземпляр блока `submit`) будет выполнен метод `_onSubmit` формы
(экземпляр блока `my-form`).

```js
DOM.decl('my-form', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.findBlockInside('submit').on(
                    'click', // имя BEM-события
                    this._onSubmit, // метод экземпляра блока my-form
                    this); // контекст для выполнения _onSubmit — блок my-form
            }
        }
    },

    _onSubmit: function() { /* ... */ }
});
```

-------------------------------------------------------------------------------

**NB** Если не указывать последний параметр метода `on` —
  `[handlerCtx]`, контекстом для выполнения функции-обработчика будет
  тот блок, в котором возникло BEM-событие. (В примере выше — это блок
  `submit`.)

-------------------------------------------------------------------------------


**Удаление подписки** на BEM-события выполняется автоматически при
уничтожении экземпляра блока. Если требуется удалить подписку вручную
в процессе работы блока, следует использовать метод экземпляра блока
`un(event, [handler], [handlerCtx])`.


<a name="bem-events-delegated"></a>

### Делегирование BEM-событий ###

Делегирование BEM-событий означает, что блок подписывается на
определенное BEM-событие **всех экземпляров** блока с заданным именем
**в пределах заданного контекста**. Подписка на делегированные
BEM-события выполняется с помощью статического метода *класса блока*
`on([ctx], event, [data], handler, [handlerCtx])`.

Параметры:

* `{jQuery} [ctx]` — DOM-узел, в пределах которого отслеживаются
BEM-события (контейнер). Если не указан, в качестве контейнера
используется весь документ.
* `{String} event` — Имя BEM-события.
* `{Object} [data]` — Произвольные данные, передаваемые
  функции-обработчику.
* `{Function} handler` — Функция-обработчик события.
* `{Object} [handlerCtx]` — Контекст функции-обработчика
  события. Обычно в качестве контекста должен выступать тот экземпляр
  блока, который подписывается на BEM-событие, а не тот, в котором BEM-событие
  произошло.


**Пример**: При инициализации экземпляров блока `menu` выполняется
  подписка на BEM-событие `click` всех ссылок (экземпляров блока
  `link`) в пределах DOM-узла, к которому привязано меню
  (`this.domElem`). В качестве контекста функции-обработчика
  передается экземпляр блока, в котором событие будет обрабатываться
  (`this`). При [уничтожении экземпляров блока](#destruct) `menu`

```js
DOM.decl('menu', {
    onSetMod : {
        'js' : {
            'inited' : function() {
                DOM.blocks['link'].on( // подписка на BEM-событие
                    this.domElem, // контейнер — DOM-узел экземпляра блока menu
                    'click', // BEM-событие
                    this._onLinkClick, // обработчик
                    this); // контекст обработчика — экземпляр блока menu
            },

            '' : function() {
                DOM.blocks['link'].un( // удаление подписки на BEM-событие
                    this.domElem,
                    'click',
                    this._onLinkClick,
                    this);
            }
        }
    },

    _onLinkClick : function(e) {
        var clickedLink = e.target; // экземпляр блока 'link', на котором произошло BEM-событие 'click'
    }
});
```

-------------------------------------------------------------------------------

**NB** Если не указывать параметр `[handlerCtx]` метода `on`,
  контекстом для функции-обработчика будет тот блок, в котором
  *возникло* BEM-событие.

-------------------------------------------------------------------------------

**Удаление подписки** на делегированные BEM-события никогда не
  происходит автоматически. Всегда следует явно удалять подписку при
  помощи статического метода блока `un([ctx], event, [handler],
  [handlerCtx])`.


Полное описание API для работы с BEM-событиями содержится в исходном
коде модулей [`i-bem`][] и [`i-bem__dom`][].


<a name="api"></a>

## Объект BEM-события ##

В качестве параметра функции-обработчику передается объект,
описывающий BEM-событие. Объект BEM-события `events.Event` определен
в [ymaps][]-модуле
[`events`](https://github.com/bem/bem-core/blob/v1/common.blocks/events/events.vanilla.js)
библиотеки bem-core. Содержит поля:

* `target` — Экземпляр блока, в котором произошло BEM-событие.
* `data` — Произвольные дополнительные данные. Передается в качестве
  параметра `data` в момент подписки на BEM-событие или при создании
  BEM-события блоком.
* `result` — Последнее значение, возвращенное обработчиком данного
  события. Аналогично [jQuery.Event.result](http://api.jquery.com/event.result/).
* `type` — Тип события. Аналогично
[jQuery.Event.type](http://api.jquery.com/event.type/).


<a name="ibc"></a>

# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока. Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида:

* Описание состояния — действия, выполняемые при переходе в данное состояние.

<a name="modifiers"></a>

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

* Модификатор — это **имя** и **значение**. Например, `size`: `m`.

* **Простой модификатор**. Частный случай, когда модификатор либо
  присутствует у блока, либо отсутствует. Например, `disabled`. В
  *i-bem.js* представлены как модификаторы с булевым
  значением. Например: `disabled`: `true`. При выставлении
  модификатора с неуказанным значением *i-bem.js* автоматически
  присваивает ему значение `true`.

* Каждому блоку можно установить один или несколько модификаторов.

* Блок может не иметь модификаторов.

В *i-bem.js* модификаторы устанавливаются при
  [инициализации экземпляра блока](#init) (если модификаторы и их
  значения указаны в атрибуте `class` соответствующего HTML-элемента).

-------------------------------------------------------------------------------

**NB** При инициализации блока с модификаторами триггеры на установку
  данных модификаторов *не выполняются*, так как экземпляр блока в
  этом случае получает начальное состояние, а не меняет его.

-------------------------------------------------------------------------------

Модификаторы могут добавляться, удаляться и менять значения:

* В ходе выполнения кода блока (например, в качестве реакции на [DOM-события](#dom-events)).
* По запросу из другого блока. Подробнее см. раздел [Взаимодействие блоков](#ibc).

При добавлении, удалении и изменении значений модификаторов выполняются триггеры.


<a name="mods-api"></a>

### Управление модификаторами ###

Экземпляр блока предоставляет методы для установки, проверки значений
и удаления модификаторов данного экземпляра.

-------------------------------------------------------------------------------

**NB**: Модификаторы нельзя устанавливать, напрямую меняя CSS-классы на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать описанное ниже API, предоставляемое *i-bem.js*.

-------------------------------------------------------------------------------

**Пример**: Экземпляр блока `square` может по клику на DOM-элементе
блока переключаться между значениями `green` и `red` модификатора
`color`, если не выставлен модификатор `disabled`:

```js
DOM.decl('square', {
    onSquareClick: function(e) {
        if(!this.hasMod('disabled')) {
            this.toggleMod('color', 'green', 'red');
        }
    }
});
```

Эти же методы используются для управления модификаторами элементов
блока. Для этого в качестве первого (необязательного) параметра
указывается ссылка на объект элемента (а не имя элемента).

**Пример**: Блок `searchbox` по клику может выставлять своему элементу
`input` простой модификатор `clean` (подразумеваемое значение —
`true`):

```js
DOM.decl('searchbox', {
    _onClick: function() {
        this.setMod(this.elem('input'), 'clean');
    }
});
```

-------------------------------------------------------------------------------

**NB** При управлении модификаторами элементов в качестве первого
  параметра необходимо указывать ссылку на **DOM-узел элемента**, а не
  имя элемента. В противном случае возникла бы неоднозначность:
  имеется в виду установка блоку *модификатора* `input` в значение
  `clean` или установка элементу `input` *простого модификатора* `clean`.

-------------------------------------------------------------------------------

Полное описание API для управления модификаторами приведено в
исходном коде модулей [`i-bem`][] и [`i-bem__dom`][].


## Триггеры на установку модификаторов ##

Выполнение триггеров на установку модификаторов разбито на две фазы:

1. **До установки модификатора**. Эта фаза зарезервирована для
   возможности **отменить** установку модификатора. Если хотя бы один
   из триггеров, выполняемых в этой фазе, вернет `false`, установки
   модификатора не произойдет.
2. **После установки модификатора**. Триггеры, выполняемые в этой
   фазе, уже не могут отменить установку модификаторов.


Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:

1. установка *любого* модификатора в *любое* значение;
2. установка *конкретного* модификатора `modName` в *любое* значение (в том числе
   установка простого модификатора в значение `true`);
3. установка *конкретного* модификатора `modName` в *конкретное* значение `modVal`;
4. установка модификатора в значение `''` (пустая строка), что
   эквивалентно удалению модификатора или установке простого
   модификатора в значение `false`).


При установке модификатора `modName` в значение `modVal` триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий (от общего к частному).

Таким образом, при определении триггера пользователь указывает:

* фазу выполнения (до или после установки модификатора);
* тип события (имя и устанавливаемое значение модификатора).

### Декларация триггеров ###

Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
  **модификаторов блока**.
* `beforeElemSetMod` — триггеры, вызываемые до установки
  **модификаторов элементов**.
* `onSetMod` — триггеры, вызываемые после установки
  **модификаторов блока**.
* `onElemSetMod` — триггеры, вызываемые после установки
  **модификаторов элементов** блока.

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl(/* селектор блока */,
    {
        /* методы экземпляра */
        beforeSetMod: { /* триггеры до установки модификаторов блока*/}
        beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}
        onSetMod: { /* триггеры после установки модификаторов блока */ }
        onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
    },
    {
        /* статические методы */
    }
);

provide(DOM);

});
```

Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий
изменения модификаторов с триггерами. В качестве параметров триггерам
передаются:

* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (для `beforeElemSetMod`) или текущее (для `onElemSetMod`) значение модификатора.

```js
{
    'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    'mod2': {
        'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    'mod3': {
        'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        '': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
```

Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

```js
beforeSetMod: function(modName, modVal, prevModVal) { /* ... */ }
onSetMod: function(modName, modVal, prevModVal) { /* ... */ }
```

Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности, задающий **элемент**,
на установку модификаторов которого устанавливаются триггеры. В
качестве параметров триггеру передаются:

* имя элемента;
* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (для `beforeElemSetMod`) или текущее (для `onElemSetMod`) значение модификатора.


```js
{
    'elem1': {
        'mod1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod1 элемента elem 1 в любое значение
        'mod2': {
            'val1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 элемента elem1 в значение val1
            'val2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку mod2 элемента elem1 в значение val2
            }
        },
    'elem2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора элемента elem2 в любое значение
}
```

Сокращенная запись для триггера на установку любого модификатора элемента
`elem1` в любое значение:

```js
beforeElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
onElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
```

### Примеры триггеров ###

Типовая задача триггеров, вызываемых после установки модификатора или
изменения его значения (свойство `onSetMod`) — выполнить операции над
DOM-узлом блока, необходимые при переходе в новое состояние.

**Пример**: Экземпляр блока `input` при установке простого
  модификатора `focused` (в значение `true`) очищает поле ввода —
  заменяет пустой строкой текст DOM-узла блока.

```js
DOM.decl('input', {
    onSetMod : {
        'focused' : {
            'true' : function() {
                this.domElem.val(''); // очистить поле ввода
            }
        }
    }
});
```

Триггеры, выполняемые перед установкой модификатора (свойство
`beforeSetMod`), необходимы для проверки текущего состояния экземпляра
блока и возможности отменить переход в другое состояние.

**Пример**: Экземпляр блока `input` перед установкой простого
  модификатора `focused` проверяет, не выставлен ли у него модификатор
  `disabled`. Если `disabled` выставлен, проверка вернет `false` и
  установки модификатора `focused` не произойдет.

```js
DOM.decl('input', {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled'); // вернет false, если disabled
            }
        }
    }
});
```


<a name="init"></a>

## Инициализация ##

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация экземпляров блоков выполняется
методом `init()` модуля `i-bem__dom` на заданном фрагменте DOM-дерева.

Каждому экземпляру блока можно приписать три состояния:

* экземпляр блока не инициализирован (JS-объект не создан);
* экземпляр блока инициализирован (JS-объект создан в памяти браузера);
* экземпляр блока уничтожен (удалены все ссылки на JS-объект экземпляра
  блока и он может быть удален сборщиком мусора).

В *i-bem.js* эти состояния экземпляра блока описываются с помощью служебного
модификатора `js`.

* До инициализации экземпляр блока не имеет модификатора `js`.

```HTML
<div class="my-block i-bem" data-bem="..." >...</div>
```

* В момент инициализации экземпляру блока устанавливается модификатор
  `js` в значении `inited`.

```HTML
<div class="my-block i-bem my-block_js_inited" data-bem="...">...</div>
```

* Если в процессе работы удаляется фрагмент DOM-дерева (при помощи
  метода `destruct` модуля `i-bem__dom`) , то вместе с
  ним удаляются экземпляры блоков, все HTML-элементы которых находятся
  в этом фрагменте. Перед удалением экземпляра блока модификатор `js`
  удаляется.

-------------------------------------------------------------------------------

**NB** Если экземпляр блока был
  [привязан к нескольким HTML-элементам](#distrib-block), блок будет существовать,
  пока в HTML-дереве сохраняется хотя бы один элемент, с которым он
  связан.

-------------------------------------------------------------------------------


Если на HTML-элементе размещено несколько экземпляров других блоков, то
инициализация одного из них (появление модификатора `my-block_js_inited`)
не влияет на инициализацию остальных.

**Пример**: На HTML-элементе инициализирован только экземпляр блока `my-block`,
экземпляр блока `lazy-block` не инициализирован:

```HTML
<div class="my-block my-block_js_inited lazy-block i-bem"
    data-bem='{ "my-block": {}, "lazy-block": {} }' >
    ...
</div>
```

-------------------------------------------------------------------------------

**NB** Наличие модификатора `js` позволяет писать разные CSS-стили для
  блока в зависимости от того, инициализирован он или нет.

-------------------------------------------------------------------------------


### Конструктор экземпляра блока ###

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` выполняется
при создании блока. Этот триггер можно считать **конструктором
экземпляра блока**:

```js
onSetMod: {
    'js': {
        'inited': function() { /* ... */ } // конструктор экземпляра блока
    }
}
```


<a name="destruct"></a>

### Деструктор экземпляра блока ###

Моментом удаления блока является момент уничтожения всех ссылок на
JS-объект блока, после чего он может быть удален из памяти браузера
сборщиком мусора.

Триггер на удаление модификатора `js` (установку в пустое значение
`''`) выполняется перед удалением блока. Такой триггер можно считать
**деструктором экземпляра блока**.

```js
onSetMod: {
    'js': {
        '': function() { /* ... */ } // деструктор экземпляра блока
    }
}
```


<a name="init-wave"></a>

### Волны инициализации ###

Инициализация экземпляров блоков, присутствующих на странице, не
обязательно происходит одновременно. Блоки могут добавляться в ходе
работы (например, за счет динамической генерации HTML на основе
данных, пришедших с сервера) или инициализироваться только по запросу.
Инициализация очередной группы блоков называется **волной
инициализации**.

Новая волна инициализации создается в следующих случаях:

* [Автоматическая инициализация всех блоков в документе по событию `domReady`](#init-auto);
* [Инициализация блока по событию на DOM-узле](#init-live) (ленивая инициализация);
* [Явный вызов инициализации блоков на указанном фрагменте DOM-дерева](#init-ajax).


<a name="init-auto"></a>

### Автоматическая инициализация ###

Фреймворк *i-bem.js* позволяет автоматически инициализировать все блоки,
имеющие DOM-представление (привязанные к DOM-элементам на странице) в
момент наступления DOM-события `domReady`. Для этого необходимо
задекларировать на странице блок `i-bem` с модификатором `init` в
значении `auto`. Пример файла `.deps.js`:

```js
({
    shouldDeps: [
        {
            block: 'i-bem',
            elem: 'dom',
            mods: { 'init': 'auto' }
        }
    ]
})
```

При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте `class` которых указан
`i-bem`. Инициализация выполняется функцией `init` модуля
[`i-bem__dom`][].

<a name="init-live"></a>

### Инициализация по событию (ленивая инициализация) ###

Автоматическая инициализация всех блоков в момент загрузки страницы
может быть нежелательной, так как при большом количестве экземпляров
блоков на странице увеличивается время загрузки и объем затраченной
памяти браузера.

В этом случае имеет смысл инициализировать JS-объекты только в тот
момент, когда их функциональность потребуется пользователю, например,
по клику на блоке. Такая инициализация называется **ленивой** или
**live-инициализацией**.

Для описания условий ленивой инициализации зарезервировано свойство
`live` в разделе статических методов декларации блока. Свойство `live`
может принимать два типа значений:

* `Boolean`.<br/> Если `live` установлено в значение `true`, экземпляры
  блоков данного класса будут инициализированы только при попытке
  получить соответствующий экземпляр. Подробнее
  см. раздел [Взаимодействие блоков](#ibc).

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // этот код будет выполняться
                                                   // при первом обращении к экземпляру блока
            }
        }
    },
    { live: 'true' } // статические методы и свойства
);

provide(DOM);

});
```

* `Function`.<br/> Функция, указанная в качестве значения `live`:

    * Выполняется один раз — при попытке инициализации **первого
    экземпляра** блока заданного класса.
    * Если функция возвращает значение `false`, экземпляры блоков
      будут инициализироваться [автоматически](#init-auto).

С помощью этой функции можно организовать инициализацию экземпляров
блока по наступлению DOM-событий на DOM-узле блока и вложенных элементах
или BEM-событий на вложенных блоках. Для этого в коде
функции следует выполнить подписку на
[делегированные события](#delegated-events).


**Пример**: Экземпляры блока `my-block` будут инициализироваться по
  DOM-событию `click` на DOM-узле блока. По каждому DOM-событию
  `click` будет вызываться метод экземпляра блока `_onClick`:

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // выполняется при первом DOM-событии 'click'
            }
        },

        _onClick: function() { /* ... */ } // выполняется при каждом DOM-событии 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function() {
                this._onClick(); // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            });
        }
    }
);

provide(DOM);

});
```

Если необходимо воспользоваться делегированными событиями в блоке, но
инициализацию блока нельзя отложить (экземпляры блока должны быть
инициализированы немедленно после загрузки страницы), следует вернуть
значение `false`:


```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // будет выполнена по наступлении domReady
            }
        },

        _onClick: function() { /* ... */ } // будет выполняться каждый
                                           // раз при наступлении DOM-события 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function() { this._onClick() });
            return false; // экземпляры блоков будут инициализированы автоматически
        }
    }
);

provide(DOM);

});
```

Полный список хелперов для подписки на делегированные события
приведен исходном коде модуля [`i-bem__dom`][].

-------------------------------------------------------------------------------

**NB** Свойство `live` задает ленивую инициализацию для *всех
  экземпляров* соответствующего блока, так как технически относится к
  статическим методам класса блока. Поэтому даже если свойство `live`
  задекларировано для блока с определенным значением модификатора, оно
  будет применено ко всем блокам данного класса вне зависимости от
  модификаторов.

-------------------------------------------------------------------------------


<a name="init-ajax"></a>

### Инициализация и удаление блоков на фрагменте DOM-дерева ###

Процедура инициализации или уничтожения JS-объектов может быть вызвана
явно для указанного фрагмента DOM-дерева. Часто такая необходимость
возникает при разработке AJAX-интерфейсов, когда нужно [динамически
встроить в страницу новые экземпляры блоков](#dynamic) либо обновить существующие.

В *i-bem.js* следующие функции выполняют динамическую инициализацию блоков:

* Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева
  (`init`, `destruct`);
* Добавление/замена фрагмента DOM-дерева с одновременной
  инициализацией блоков на обновленном фрагменте (`update`, `replace`,
  `append`, `prepend`, `before`, `after`).


<a name="init-bem"></a>

### Инициализация и удаление блоков без DOM-представления ###

Чтобы создать JS-объект для блока, не имеющего DOM-представления (не
привязанного к HTML-элементу), необходимо вызвать метод `create`,
который вернет экземпляр блока указанного класса.

**Пример**: В момент инициализации экземпляра блока с DOM-представлением
  `container` создается экземпляр блока без DOM-представления `router`. Экземпляр блока
  `container` затем будет обращаться к созданному им экземпляру блока
  `router` при вызове метода `onRequest`:

```js
modules.define('i-bem__dom', 'i-bem', function(provide, BEM, DOM) {

DOM.decl('container', {
    onSetMod: {
        'js': {
            'inited': function() {
                this._router = BEM.create('router'); // создание экземпляра блока router
            }
        }
    },

    onRequest: function() {
        this._router.route(/* ... */) // вызов метода экземпляра блока router
    }
});

provide(DOM);

});
```

**Пример**: Блок без DOM-представления реализован в виде простого
  [ymaps-модуля][ymaps], без использования модуля `i-bem`. Такой блок
  используется как обычный ymaps-модуль (нет необходимости создавать
  экземпляр блока):

```js
modules.define('i-bem__dom', 'router', function(provide, DOM, router) {

DOM.decl('container', {
    onRequest: function() {
        router.route(/* ... */); // вызов метода блока router
    }
});

provide(DOM, router);

});
```

**Удаление** экземпляров блоков без DOM-представления не может быть
выполнено автоматически и является ответственностью
разработчика. Блоки без DOM-представления представляют собой обычные
JS-объекты и удаляются в момент удаления всех ссылок на объект блока.


**Пример**: При удалении экземпляра блока `container` удаляется созданный им в
процессе работы экземпляр блока без DOM-представления `router`.

```js
modules.define('i-bem__dom', 'i-bem', function(provide, BEM, DOM) {

DOM.decl('container', {
    onSetMod : {
        'js' : {
            '' : function() {
                delete this._router; // удаление экземпляра блока router
            }
        }
    }
});

provide(DOM);

});
```

# Взаимодействие блоков #

БЭМ-методология предполагает, что блоки должны разрабатываться таким
образом, чтобы по возможности исключить зависимость состояний одних
блоков от других. Однако на практике идеал полной независимости блоков
недостижим.

Взаимодействие блоков может быть реализовано двумя способами:

* С помощью подписки на [BEM-события](#bem-events) других экземпляров
  блоков или подписки на [делегированные BEM-события](#bem-events-delegated).
* С помощью непосредственного вызова методов других экземпляров
  блоков или статических методов класса другого блока.

-------------------------------------------------------------------------------

**NB** Не используйте [DOM-события](#dom-events) для
  организации взаимодействия между блоками. DOM-события предназначены
  только для реализации внутренних процедур блока.

-------------------------------------------------------------------------------

Для реализации взаимодействия блоков *i-bem.js* предоставляет API для
доступа к JS-объектам экземпляров блоков и к JS-объектам классов блоков.

## Поиск экземпляров блоков в DOM-дереве ##

Обращение к другому блоку в *i-bem.js* выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:

* «Внутри блока» — на DOM-узлах, вложенных в DOM-узел текущего блока.
* «Снаружи блока» — на DOM-узлах, потомком которых является DOM-узел
  текущего блока. Необходимость в таком поиске может свидетельствовать
  о неудачной архитектуре интерфейса.
* «На себе» — на том же DOM-узле, на котором размещен текущий
  блок. Это актуально в случае [размещения нескольких JS-блоков на
  одном DOM-узле](#mixes) (микс).

**Пример**: При переключении модификатора `disabled` экземпляр блока
  `attach` находит вложенный в него блок `button` и переключает его
  модификатор `disabled` в то же значение, которое получил сам:

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('attach', {
    onSetMod: {
        'disabled': function(modName, modVal) {
            this.findBlockInside('button').setMod(modName, modVal);
        }
    }
});

provide(DOM);

});
```

Полный список методов для поиска блоков блоков приведен
в исходном коде модуля [`i-bem__dom`][].


-------------------------------------------------------------------------------

**NB** Не используйте jQuery-селекторы для поиска блоков и элементов.
*i-bem.js* предоставляет высокоуровневое API для доступа к DOM-узлам
блоков и элементов. Обращение к DOM-дереву в обход этого API менее
устойчивым к изменениям БЭМ-библиотек и может привести к возникновению
сложно обнаруживаемых ошибок.

-------------------------------------------------------------------------------

## Доступ к экземплярам блоков без DOM-представления ##

При создании экземпляра блока без DOM-представления необходимо
позаботиться о том, чтобы ссылка на этот экземпляр была доступна
блокам, которым потребуется взаимодействовать с ним. Подробности и
пример см. в разделе [Инициализация и удаление блоков без DOM-представления](#init-bem).


## Доступ к классам блоков ##

JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных `BEM.blocks`. Классы блоков,
[не привязанных к DOM-дереву](#i-blocks), также размещены в этой
структуре данных. При необходимости доступа к таким блокам следует
использовать конструкцию:
```js
BEM.blocks['name']
```
где `name` — имя блока.

Доступ к классам блоков необходим для решения двух основных задач:

* [Делегирование БЭМ-событий](#bem-events-delegated).
* Вызов статического метода класса.

**Пример**: Вызов статического метода `close` блока `popup` — закрыть
  все попапы на странице:

```js
DOM.decl('switcher', {
    onSetMod : {
        'popup' : {
            'disabled' : function() {
                BEM.blocks['popup'].close();
            }
        }
    }
});
```

<a name="docs"></a>

# Что дальше? #

Общую информацию о БЭМ-методологии, инструментарии, новостях в мире
БЭМ можно найти на сайте [bem.info](http://ru.bem.info/).

Полную информацию обо всех методах API *i-bem.js* можно найти в
исходном коде, который сопровождается структурированными комментариями
в формате JSDoc:

* [`i-bem`][];
* [`i-bem__dom`][].

Задать вопрос опытным пользователям и разработчикам *i-bem.js* и
следить за текущими обсуждениями можно в социальных сетях:

* [Клуб в Я.ру](http://clubs.ya.ru/bem/);
* [Группа в Facebook](http://www.facebook.com/#!/groups/209713935765634/);
* [Twitter](https://twitter.com/bem_ru).

Прочитать о принципах работы *i-bem.js* в другом изложении, найти
образцы его применения и пошаговые инструкции на примере простых
проектов можно в статьях:

* [JavaScript по БЭМ: основные понятия](http://ru.bem.info/articles/bem-js-main-terms/);
* [Tutorial on JavaScript in BEM terms](https://github.com/varya/bem-js-tutorial);
* [Попробуй БЭМ на вкус!](http://habrahabr.ru/post/162385/);
* [БЭМ-приложение на Leaflet и API 2GIS](http://ru.bem.info/articles/firm-card-story/).


-------------------------------------------------------------------------------

**NB** Обратите внимание, что в перечисленных статьях может
использоваться устаревший синтаксис, не соответствующий текущей версии
*i-bem.js*, включенной в bem-core.

-------------------------------------------------------------------------------


[ymaps]: https://github.com/ymaps/modules

[bem-tools]: http://ru.bem.info/tools/bem/

[`i-bem`]: https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js

[`i-bem__dom`]: https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js
